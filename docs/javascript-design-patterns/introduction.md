---
sidebar_position: 0
---

# Introduction

In this section, we will explore JavaScript implementations of a number of both classic and modern design patterns.

Developers commonly wonder whether there is an ideal pattern or set of patterns they should be using in their workflow. There isn't a true single answer to this question; each script and web application we work on is likely to have its own individual needs and we need to think about where we feel a pattern can offer real value to an implementation.

For example, some projects may benefit from the decoupling benefits offered by the Observer pattern (which reduces how dependent parts of an application are on one another) whilst others may simply be too small for decoupling to be a concern at all.

That said, once we have a firm grasp of design patterns and the specific problems they are best suited to, it becomes much easier to integrate them into our application architectures.

The patterns we will be exploring in this section are the:

- [Constructor Pattern](constructor-pattern)
- [Module Pattern](module-pattern)
- [Revealing Module Pattern](revealing-module-pattern)
- [Singleton Pattern](singleton-pattern)
- [Observer Pattern](observer-pattern)
- [Mediator Pattern](mediator-pattern)
- [Prototype Pattern](prototype-pattern)
- [Command Pattern](command-pattern)
- [Facade Pattern](facade-pattern)
- [Factory Pattern](factory-pattern)
- [Mixin Pattern](mixin-pattern)
- [Decorator Pattern](decorator-pattern)
- [Flyweight Pattern](flyweight-pattern)
